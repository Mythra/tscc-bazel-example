import { IInputTsccSpecJSON, ITsccSpecJSON, TsccSpec } from '@tscc/tscc-spec';
import * as ts from 'typescript';
import ITsccSpecWithTS from './ITsccSpecWithTS';
export declare class TsError extends Error {
    diagnostics: ReadonlyArray<ts.Diagnostic>;
    constructor(diagnostics: ReadonlyArray<ts.Diagnostic>);
}
declare type TWarningCallback = (msg: string) => void;
export default class TsccSpecWithTS extends TsccSpec implements ITsccSpecWithTS {
    private parsedConfig;
    private projectRoot;
    static loadTsConfigFromArgs(tsArgs: string[], specRoot: string, onWarning: TWarningCallback): {
        projectRoot: string;
        parsedConfig: ts.ParsedCommandLine;
    };
    static loadTsConfigFromPath(tsConfigPath?: string, specRoot?: string, compilerOptions?: object): {
        projectRoot: string;
        parsedConfig: ts.ParsedCommandLine;
    };
    private static findConfigFileAndThrow;
    private static loadTsConfigFromResolvedPath;
    static loadSpecWithTS(tsccSpecJSONOrItsPath: string | IInputTsccSpecJSON, tsConfigPathOrTsArgs?: string | string[], compilerOptionsOverride?: object, onTsccWarning?: (msg: string) => void): TsccSpecWithTS;
    /**
     * Prune compiler options
     *  - "module" to "commonjs"
     *  - Get values of outDir, strip it, and pass it to closure compiler
     *  - Warn when rootDir is used - it is of no use.
     */
    private static pruneCompilerOptions;
    private tsCompilerHost;
    constructor(tsccSpec: ITsccSpecJSON, basePath: string, parsedConfig: ts.ParsedCommandLine, projectRoot: string);
    protected validateSpec(): void;
    getTSRoot(): string;
    getCompilerOptions(): ts.CompilerOptions;
    getCompilerHost(): ts.CompilerHost;
    private static readonly tsTargetToCcTarget;
    getOutputFileNames(): string[];
    private getDefaultFlags;
    getBaseCompilerFlags(): string[];
    getAbsoluteFileNamesSet(): Set<string>;
    resolveExternalModuleTypeReference(moduleName: string): string | null;
    getProjectHash(): string;
}
export {};
